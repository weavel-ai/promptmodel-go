// This file was auto-generated by Fern from our API Definition.

package api

import (
	bytes "bytes"
	context "context"
	json "encoding/json"
	errors "errors"
	fmt "fmt"
	io "io"
	http "net/http"
	url "net/url"

	core "github.com/weavel-ai/promptmodel-go/core"
)

type Client struct {
	baseURL string
	caller  *core.Caller
	header  http.Header
}

func NewClient(opts ...core.ClientOption) *Client {
	options := core.NewClientOptions()
	for _, opt := range opts {
		opt(options)
	}
	return &Client{
		baseURL: options.BaseURL,
		caller:  core.NewCaller(options.HTTPClient),
		header:  options.ToHeader(),
	}
}

// Only use when use_cache = False. Find published version of function_model_version and prompt and return them. Input: - function_model_name: name of function_model
// Return: - function_model_versions : List[Dict] - prompts : List[Dict]
func (c *Client) FetchFunctionModelVersion(ctx context.Context, request *FetchFunctionModelVersionRequest) (*FetchFunctionModelVersionResponseInstance, error) {
	baseURL := ""
	if c.baseURL != "" {
		baseURL = c.baseURL
	}
	endpointURL := baseURL + "/" + "api/cli/function_model_versions"

	queryParams := make(url.Values)
	queryParams.Add("function_model_name", fmt.Sprintf("%v", request.FunctionModelName))
	if request.Version != nil {
		queryParams.Add("version", fmt.Sprintf("%v", *request.Version))
	}
	if len(queryParams) > 0 {
		endpointURL += "?" + queryParams.Encode()
	}

	errorDecoder := func(statusCode int, body io.Reader) error {
		raw, err := io.ReadAll(body)
		if err != nil {
			return err
		}
		apiError := core.NewAPIError(statusCode, errors.New(string(raw)))
		decoder := json.NewDecoder(bytes.NewReader(raw))
		switch statusCode {
		case 422:
			value := new(UnprocessableEntityError)
			value.APIError = apiError
			if err := decoder.Decode(value); err != nil {
				return apiError
			}
			return value
		}
		return apiError
	}

	var response *FetchFunctionModelVersionResponseInstance
	if err := c.caller.Call(
		ctx,
		&core.CallParams{
			URL:          endpointURL,
			Method:       http.MethodGet,
			Headers:      c.header,
			Response:     &response,
			ErrorDecoder: errorDecoder,
		},
	); err != nil {
		return nil, err
	}
	return response, nil
}

func (c *Client) FetchFunctionModelVersionAsync(ctx context.Context, request *FetchFunctionModelVersionRequest, responseChan chan *FetchFunctionModelVersionResponseInstance, errorChan chan error) {
	go func() {
		response, err := c.FetchFunctionModelVersion(ctx, request)
		if err != nil {
			errorChan <- err
			return
		}
		responseChan <- response
	}()
}

// ChatModel Always use this function when use_cache = True or False
// Find version of chat_model_version
// Input: - chat_model_name: name of chat_model - session_uuid: uuid of session - version
// Return: - Dict - chat_model_versions : List[Dict] -
func (c *Client) FetchChatModelVersionWithChatLog(ctx context.Context, request *FetchChatModelVersionWithChatLogRequest) (*FetchChatModelVersionResponseInstance, error) {
	baseURL := ""
	if c.baseURL != "" {
		baseURL = c.baseURL
	}
	endpointURL := baseURL + "/" + "api/cli/chat_model_versions_with_logs"

	queryParams := make(url.Values)
	queryParams.Add("chat_model_name", fmt.Sprintf("%v", request.ChatModelName))
	if request.SessionUuid != nil {
		queryParams.Add("session_uuid", fmt.Sprintf("%v", *request.SessionUuid))
	}
	if request.Version != nil {
		queryParams.Add("version", fmt.Sprintf("%v", *request.Version))
	}
	if len(queryParams) > 0 {
		endpointURL += "?" + queryParams.Encode()
	}

	errorDecoder := func(statusCode int, body io.Reader) error {
		raw, err := io.ReadAll(body)
		if err != nil {
			return err
		}
		apiError := core.NewAPIError(statusCode, errors.New(string(raw)))
		decoder := json.NewDecoder(bytes.NewReader(raw))
		switch statusCode {
		case 422:
			value := new(UnprocessableEntityError)
			value.APIError = apiError
			if err := decoder.Decode(value); err != nil {
				return apiError
			}
			return value
		}
		return apiError
	}

	var response *FetchChatModelVersionResponseInstance
	if err := c.caller.Call(
		ctx,
		&core.CallParams{
			URL:          endpointURL,
			Method:       http.MethodGet,
			Headers:      c.header,
			Response:     &response,
			ErrorDecoder: errorDecoder,
		},
	); err != nil {
		return nil, err
	}
	return response, nil
}

func (c *Client) FetchChatModelVersionWithChatLogAsync(ctx context.Context, request *FetchChatModelVersionWithChatLogRequest, responseChan chan *FetchChatModelVersionResponseInstance, errorChan chan error) {
	go func() {
		response, err := c.FetchChatModelVersionWithChatLog(ctx, request)
		if err != nil {
			errorChan <- err
			return
		}
		responseChan <- response
	}()
}


func (c *Client) SaveRunLogScore(ctx context.Context, request *SaveRunLogScoreRequest) (interface{}, error) {
	baseURL := ""
	if c.baseURL != "" {
		baseURL = c.baseURL
	}
	endpointURL := baseURL + "/" + "api/cli/run_log_score"

	queryParams := make(url.Values)
	queryParams.Add("run_log_uuid", fmt.Sprintf("%v", request.RunLogUuid))
	if len(queryParams) > 0 {
		endpointURL += "?" + queryParams.Encode()
	}

	errorDecoder := func(statusCode int, body io.Reader) error {
		raw, err := io.ReadAll(body)
		if err != nil {
			return err
		}
		apiError := core.NewAPIError(statusCode, errors.New(string(raw)))
		decoder := json.NewDecoder(bytes.NewReader(raw))
		switch statusCode {
		case 422:
			value := new(UnprocessableEntityError)
			value.APIError = apiError
			if err := decoder.Decode(value); err != nil {
				return apiError
			}
			return value
		}
		return apiError
	}

	var response interface{}
	if err := c.caller.Call(
		ctx,
		&core.CallParams{
			URL:          endpointURL,
			Method:       http.MethodPost,
			Headers:      c.header,
			Request:      request,
			Response:     &response,
			ErrorDecoder: errorDecoder,
		},
	); err != nil {
		return nil, err
	}
	return response, nil
}

func (c *Client) SaveRunLogScoreAsync(ctx context.Context, request *SaveRunLogScoreRequest, responseChan chan interface{}, errorChan chan error) {
	go func() {
		response, err := c.SaveRunLogScore(ctx, request)
		if err != nil {
			errorChan <- err
			return
		}
		responseChan <- response
	}()
}

func (c *Client) SaveChatSessionScore(ctx context.Context, request *SaveChatSessionScoreRequest) (interface{}, error) {
	baseURL := ""
	if c.baseURL != "" {
		baseURL = c.baseURL
	}
	endpointURL := baseURL + "/" + "api/cli/chat_session_score"

	queryParams := make(url.Values)
	queryParams.Add("chat_session_uuid", fmt.Sprintf("%v", request.ChatSessionUuid))
	if len(queryParams) > 0 {
		endpointURL += "?" + queryParams.Encode()
	}

	errorDecoder := func(statusCode int, body io.Reader) error {
		raw, err := io.ReadAll(body)
		if err != nil {
			return err
		}
		apiError := core.NewAPIError(statusCode, errors.New(string(raw)))
		decoder := json.NewDecoder(bytes.NewReader(raw))
		switch statusCode {
		case 422:
			value := new(UnprocessableEntityError)
			value.APIError = apiError
			if err := decoder.Decode(value); err != nil {
				return apiError
			}
			return value
		}
		return apiError
	}

	var response interface{}
	if err := c.caller.Call(
		ctx,
		&core.CallParams{
			URL:          endpointURL,
			Method:       http.MethodPost,
			Headers:      c.header,
			Request:      request,
			Response:     &response,
			ErrorDecoder: errorDecoder,
		},
	); err != nil {
		return nil, err
	}
	return response, nil
}

func (c *Client) SaveChatSessionScoreAsync(ctx context.Context, request *SaveChatSessionScoreRequest, responseChan chan interface{}, errorChan chan error) {
	go func() {
		response, err := c.SaveChatSessionScore(ctx, request)
		if err != nil {
			errorChan <- err
			return
		}
		responseChan <- response
	}()
}

func (c *Client) SaveChatMessageScore(ctx context.Context, request *SaveChatMessageScoreRequest) (interface{}, error) {
	baseURL := ""
	if c.baseURL != "" {
		baseURL = c.baseURL
	}
	endpointURL := baseURL + "/" + "api/cli/chat_message_score"

	queryParams := make(url.Values)
	queryParams.Add("chat_message_uuid", fmt.Sprintf("%v", request.ChatMessageUuid))
	if len(queryParams) > 0 {
		endpointURL += "?" + queryParams.Encode()
	}

	errorDecoder := func(statusCode int, body io.Reader) error {
		raw, err := io.ReadAll(body)
		if err != nil {
			return err
		}
		apiError := core.NewAPIError(statusCode, errors.New(string(raw)))
		decoder := json.NewDecoder(bytes.NewReader(raw))
		switch statusCode {
		case 422:
			value := new(UnprocessableEntityError)
			value.APIError = apiError
			if err := decoder.Decode(value); err != nil {
				return apiError
			}
			return value
		}
		return apiError
	}

	var response interface{}
	if err := c.caller.Call(
		ctx,
		&core.CallParams{
			URL:          endpointURL,
			Method:       http.MethodPost,
			Headers:      c.header,
			Request:      request,
			Response:     &response,
			ErrorDecoder: errorDecoder,
		},
	); err != nil {
		return nil, err
	}
	return response, nil
}

func (c *Client) SaveChatMessageScoreAsync(ctx context.Context, request *SaveChatMessageScoreRequest, responseChan chan interface{}, errorChan chan error) {
	go func() {
		response, err := c.SaveChatMessageScore(ctx, request)
		if err != nil {
			errorChan <- err
			return
		}
		responseChan <- response
	}()
}

func (c *Client) SaveRunLog(ctx context.Context, request *RunLogRequestBody) (interface{}, error) {
	baseURL := ""
	if c.baseURL != "" {
		baseURL = c.baseURL
	}
	endpointURL := baseURL + "/" + "api/cli/run_log"

	queryParams := make(url.Values)
	queryParams.Add("version_uuid", fmt.Sprintf("%v", request.VersionUuid))
	if len(queryParams) > 0 {
		endpointURL += "?" + queryParams.Encode()
	}

	errorDecoder := func(statusCode int, body io.Reader) error {
		raw, err := io.ReadAll(body)
		if err != nil {
			return err
		}
		apiError := core.NewAPIError(statusCode, errors.New(string(raw)))
		decoder := json.NewDecoder(bytes.NewReader(raw))
		switch statusCode {
		case 422:
			value := new(UnprocessableEntityError)
			value.APIError = apiError
			if err := decoder.Decode(value); err != nil {
				return apiError
			}
			return value
		}
		return apiError
	}

	var response interface{}
	if err := c.caller.Call(
		ctx,
		&core.CallParams{
			URL:          endpointURL,
			Method:       http.MethodPost,
			Headers:      c.header,
			Request:      request,
			Response:     &response,
			ErrorDecoder: errorDecoder,
		},
	); err != nil {
		return nil, err
	}
	return response, nil
}

func (c *Client) SaveRunLogAsync(ctx context.Context, request *RunLogRequestBody, responseChan chan interface{}, errorChan chan error) {
	go func() {
		response, err := c.SaveRunLog(ctx, request)
		if err != nil {
			errorChan <- err
			return
		}
		responseChan <- response
	}()
}


func (c *Client) SaveChatLog(ctx context.Context, request *SaveChatLogRequest) (interface{}, error) {
	baseURL := ""
	if c.baseURL != "" {
		baseURL = c.baseURL
	}
	endpointURL := baseURL + "/" + "api/cli/chat_log"

	queryParams := make(url.Values)
	queryParams.Add("session_uuid", fmt.Sprintf("%v", request.SessionUuid))
	if request.VersionUuid != nil {
		queryParams.Add("version_uuid", fmt.Sprintf("%v", *request.VersionUuid))
	}
	if len(queryParams) > 0 {
		endpointURL += "?" + queryParams.Encode()
	}

	errorDecoder := func(statusCode int, body io.Reader) error {
		raw, err := io.ReadAll(body)
		if err != nil {
			return err
		}
		apiError := core.NewAPIError(statusCode, errors.New(string(raw)))
		decoder := json.NewDecoder(bytes.NewReader(raw))
		switch statusCode {
		case 422:
			value := new(UnprocessableEntityError)
			value.APIError = apiError
			if err := decoder.Decode(value); err != nil {
				return apiError
			}
			return value
		}
		return apiError
	}

	var response interface{}
	if err := c.caller.Call(
		ctx,
		&core.CallParams{
			URL:          endpointURL,
			Method:       http.MethodPost,
			Headers:      c.header,
			Request:      request,
			Response:     &response,
			ErrorDecoder: errorDecoder,
		},
	); err != nil {
		return nil, err
	}
	return response, nil
}

func (c *Client) SaveChatLogAsync(ctx context.Context, request *SaveChatLogRequest, responseChan chan interface{}, errorChan chan error) {
	go func() {
		response, err := c.SaveChatLog(ctx, request)
		if err != nil {
			errorChan <- err
			return
		}
		responseChan <- response
	}()
}

func (c *Client) MakeSession(ctx context.Context, request *MakeSessionRequest) (interface{}, error) {
	baseURL := ""
	if c.baseURL != "" {
		baseURL = c.baseURL
	}
	endpointURL := baseURL + "/" + "api/cli/make_session"

	queryParams := make(url.Values)
	queryParams.Add("session_uuid", fmt.Sprintf("%v", request.SessionUuid))
	queryParams.Add("version_uuid", fmt.Sprintf("%v", request.VersionUuid))
	if len(queryParams) > 0 {
		endpointURL += "?" + queryParams.Encode()
	}

	errorDecoder := func(statusCode int, body io.Reader) error {
		raw, err := io.ReadAll(body)
		if err != nil {
			return err
		}
		apiError := core.NewAPIError(statusCode, errors.New(string(raw)))
		decoder := json.NewDecoder(bytes.NewReader(raw))
		switch statusCode {
		case 422:
			value := new(UnprocessableEntityError)
			value.APIError = apiError
			if err := decoder.Decode(value); err != nil {
				return apiError
			}
			return value
		}
		return apiError
	}

	var response interface{}
	if err := c.caller.Call(
		ctx,
		&core.CallParams{
			URL:          endpointURL,
			Method:       http.MethodPost,
			Headers:      c.header,
			Response:     &response,
			ErrorDecoder: errorDecoder,
		},
	); err != nil {
		return nil, err
	}
	return response, nil
}

func (c *Client) MakeSessionAsync(ctx context.Context, request *MakeSessionRequest, responseChan chan interface{}, errorChan chan error) {
	go func() {
		response, err := c.MakeSession(ctx, request)
		if err != nil {
			errorChan <- err
			return
		}
		responseChan <- response
	}()
}